<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Em yêu anh — Night Sky</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { margin:0; height:100%; background:#000; overflow:hidden; }
    #qr { position: fixed; right:16px; bottom:16px; background: rgba(255,255,255,0.85); padding:8px; border-radius:8px; z-index:10; }
    #music { position: fixed; left:16px; top:16px; z-index:10; }
    #hint { position: fixed; left:50%; top:8px; transform:translateX(-50%); color:#ffd1f0; font-family: sans-serif; z-index:10; }
    #controls { position: fixed; right:16px; top:16px; z-index:10; display:flex; gap:8px; }
    button { padding:6px 10px; border-radius:8px; border:none; background: rgba(255,255,255,0.14); color:#fff; cursor:pointer; }
  </style>
  <!-- Three.js UMD & OrbitControls (non-module) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
</head>
<body>
  <div id="hint">Kéo/zoom bằng chuột. Bấm "Tạo chữ" để các ngôi sao tụ thành dòng chữ.</div>
  <div id="controls">
    <button id="btnForm">Tạo chữ</button>
    <button id="btnReset">Reset</button>
  </div>

  <audio id="music" controls autoplay loop>
    <source src="https://cdn.pixabay.com/download/audio/2023/06/15/audio_61f8658c9b.mp3?filename=romantic-piano-144397.mp3" type="audio/mpeg">
  </audio>

  <div id="qr"></div>

<script>
(() => {
  const THREE = window.THREE;
  let scene, camera, renderer, controls;
  let bgStars, fgStarsGeom, fgPositions, fgVel;
  let bgUniforms;
  let hearts = [];
  let targetPoints = [];
  let forming = false;
  let formStartTime = 0;
  const clock = new THREE.Clock();

  init();
  animate();

  // QR
  QRCode.toCanvas(document.getElementById("qr"), window.location.href, { width: 110 }, err => { if(err) console.error(err); });

  document.getElementById('btnForm').addEventListener('click', () => {
    if (!forming) startForming();
  });
  document.getElementById('btnReset').addEventListener('click', () => { resetScene(); });

  function init(){
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
    camera.position.set(0, 0, 600);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false;

    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const point = new THREE.PointLight(0xffccff, 1.2, 3000); point.position.set(200,200,200); scene.add(point);

    createBackgroundStars();    // rất nhiều sao nhỏ/lớn, shader twinkle
    createForegroundStars();    // những ngôi sao sẽ tụ thành chữ
    createHearts();             // nhiều trái tim 1 màu

    // prepare text target points (but don't auto form)
    targetPoints = getPointsFromTextCanvas("em yêu anh, hôm nay anh đã vất vả rồi, anh là giỏi nhất", {
      w: 1600, h: 300, font: "bold 140px 'Segoe UI', Roboto, 'Noto Sans', Arial",
      sampleStep: 6, threshold: 128
    });

    window.addEventListener('resize', onResize);
  }

  // BACKGROUND STARS: many points, sizes array, shader twinkle
  function createBackgroundStars(){
    const STAR_COUNT = 18000; // nhiều ngôi sao
    const pos = new Float32Array(STAR_COUNT*3);
    const sizes = new Float32Array(STAR_COUNT);
    const phases = new Float32Array(STAR_COUNT);

    for(let i=0;i<STAR_COUNT;i++){
      const i3 = i*3;
      pos[i3]   = (Math.random()-0.5)*4000;
      pos[i3+1] = (Math.random()-0.5)*2800;
      pos[i3+2] = (Math.random()-0.5)*4000;
      // small majority + some large
      sizes[i] = (Math.random() < 0.85) ? (0.6 + Math.random()*1.2) : (2.0 + Math.random()*3.6);
      phases[i] = Math.random()*Math.PI*2;
    }

    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    geo.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

    bgUniforms = { time: { value: 0 } };

    // shader: twinkle + halo
    const mat = new THREE.ShaderMaterial({
      uniforms: bgUniforms,
      vertexShader: `
        attribute float size;
        attribute float phase;
        varying float vPhase;
        varying float vSize;
        void main(){
          vPhase = phase;
          vSize = size;
          vec4 mvPos = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (300.0 / -mvPos.z);
          gl_Position = projectionMatrix * mvPos;
        }
      `,
      fragmentShader: `
        uniform float time;
        varying float vPhase;
        varying float vSize;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          // core brightness
          float core = exp(-d*d*10.0);
          // twinkle
          float tw = 0.6 + 0.4 * sin(time*3.0 + vPhase*2.0);
          float alpha = core * tw;
          // slight halo
          float halo = smoothstep(0.9, 0.2, d) * 0.35;
          alpha += halo * tw * (vSize>2.0 ? 1.2 : 0.6);
          // warm-white tint
          vec3 col = vec3(1.0, 0.95, 0.85);
          gl_FragColor = vec4(col * (0.8 + 0.6*tw), alpha);
          if (gl_FragColor.a < 0.01) discard;
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    bgStars = new THREE.Points(geo, mat);
    scene.add(bgStars);
  }

  // FOREGROUND STARS: medium count, will move to form text (positions updated on CPU)
  function createForegroundStars(){
    const FG_COUNT = 3000;
    fgPositions = new Float32Array(FG_COUNT*3);
    fgVel = new Float32Array(FG_COUNT*3);
    const sizes = new Float32Array(FG_COUNT);
    const phases = new Float32Array(FG_COUNT);

    for(let i=0;i<FG_COUNT;i++){
      const i3 = i*3;
      fgPositions[i3] = (Math.random()-0.5)*1600;
      fgPositions[i3+1] = 800 + Math.random()*1200; // start high
      fgPositions[i3+2] = (Math.random()-0.5)*600;
      fgVel[i3] = (Math.random()-0.5)*0.2;
      fgVel[i3+1] = - (0.6 + Math.random()*1.8);
      fgVel[i3+2] = (Math.random()-0.5)*0.2;
      sizes[i] = (Math.random() < 0.75) ? (1.0 + Math.random()*1.4) : (3.0 + Math.random()*3.0);
      phases[i] = Math.random()*Math.PI*2;
    }

    fgStarsGeom = new THREE.BufferGeometry();
    fgStarsGeom.setAttribute('position', new THREE.BufferAttribute(fgPositions, 3));
    fgStarsGeom.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    fgStarsGeom.setAttribute('phase', new THREE.BufferAttribute(phases, 1));

    const fgUniforms = { time: { value: 0 } };

    const fgMat = new THREE.ShaderMaterial({
      uniforms: fgUniforms,
      vertexShader: `
        attribute float size;
        attribute float phase;
        varying float vPhase;
        varying float vSize;
        void main(){
          vPhase = phase;
          vSize = size;
          vec4 mv = modelViewMatrix * vec4(position, 1.0);
          gl_PointSize = size * (280.0 / -mv.z);
          gl_Position = projectionMatrix * mv;
        }
      `,
      fragmentShader: `
        uniform float time;
        varying float vPhase;
        varying float vSize;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float core = exp(-d*d*12.0);
          float tw = 0.5 + 0.5 * sin(time*4.0 + vPhase*1.7);
          float alpha = core * (0.8 + 0.7*tw);
          vec3 col = vec3(1.0, 0.92, 0.7);
          // bigger stars slightly warmer
          if (vSize > 2.5) col = vec3(1.0, 0.98, 0.85);
          gl_FragColor = vec4(col, alpha);
          if (gl_FragColor.a < 0.01) discard;
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending
    });

    const points = new THREE.Points(fgStarsGeom, fgMat);
    scene.add(points);

    // store reference to update time uniform each frame
    fgStarsGeom.userData = { material: fgMat, count: FG_COUNT };
  }

  // HEARTS: simple mesh hearts, one color
  function createHearts(){
    const shape = new THREE.Shape();
    shape.moveTo(0, 5);
    shape.bezierCurveTo(5, 15, 25, 15, 25, 5);
    shape.bezierCurveTo(25, -5, 12.5, -12, 0, -25);
    shape.bezierCurveTo(-12.5, -12, -25, -5, -25, 5);
    shape.bezierCurveTo(-25, 15, -5, 15, 0, 5);
    const geo = new THREE.ExtrudeGeometry(shape, { depth: 2, bevelEnabled: false });
    const mat = new THREE.MeshStandardMaterial({ color: 0xff4da6, emissive: 0xff2a88, emissiveIntensity: 0.9, metalness:0.4, roughness:0.3 });
    const N = 80;
    for(let i=0;i<N;i++){
      const m = new THREE.Mesh(geo, mat);
      const s = 0.035 + Math.random()*0.03;
      m.scale.setScalar(s);
      m.position.set((Math.random()-0.5)*1200, 400 + Math.random()*500, (Math.random()-0.5)*200);
      m.userData = { speed: 0.8 + Math.random()*1.6 };
      scene.add(m);
      hearts.push(m);
    }
  }

  // sample text from canvas -> return array of Vector3 targets (centered)
  function getPointsFromTextCanvas(text, opts = {}) {
    const w = opts.w || 1400, h = opts.h || 320;
    const font = opts.font || "bold 140px sans-serif";
    const step = opts.sampleStep || 6;
    const threshold = opts.threshold || 128;
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    ctx.fillStyle = 'black';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = 'white';
    ctx.font = font;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, w/2, h/2);
    const img = ctx.getImageData(0,0,w,h).data;
    const pts = [];
    for(let y=0;y<h;y+=step){
      for(let x=0;x<w;x+=step){
        const idx = (y*w+x)*4;
        if (img[idx+3] > threshold){
          // map to scene coordinates
          const sx = (x - w/2)*0.32;
          const sy = (h/2 - y)*0.32 - 60; // shift down a bit
          const sz = (Math.random()-0.5)*20;
          pts.push(new THREE.Vector3(sx, sy, sz));
        }
      }
    }
    // shuffle so mapping isn't linear
    for(let i=pts.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [pts[i], pts[j]] = [pts[j], pts[i]];
    }
    return pts;
  }

  function startForming(){
    if (forming) return;
    if (!targetPoints || targetPoints.length === 0) {
      console.warn("No text target points (increase sample density).");
      return;
    }
    forming = true;
    formStartTime = clock.getElapsedTime();

    // Map foreground stars to target points (only as many as min)
    const FG_COUNT = fgPositions.length / 3;
    const mapCount = Math.min(FG_COUNT, targetPoints.length);
    // We will set an array of target positions for each fg star (or null)
    const fgTargets = new Array(FG_COUNT).fill(null);
    // assign first mapCount stars to targets
    for (let i=0; i<mapCount; i++){
      fgTargets[i] = targetPoints[i].clone().add(new THREE.Vector3((Math.random()-0.5)*6, (Math.random()-0.5)*6, (Math.random()-0.5)*6));
    }
    // for remaining ones, leave null (they keep twinkling)

    // attach fgTargets to geometry for animate loop
    fgStarsGeom.userData.targets = fgTargets;
    // gently slow down hearts and background
    hearts.forEach(h => { h.userData.speed *= 0.3; });
  }

  function resetScene(){
    // reset positions of fg stars and hearts
    const FG_COUNT = fgPositions.length / 3;
    for(let i=0;i<FG_COUNT;i++){
      fgPositions[i*3] = (Math.random()-0.5)*1600;
      fgPositions[i*3+1] = 800 + Math.random()*1200;
      fgPositions[i*3+2] = (Math.random()-0.5)*600;
    }
    fgStarsGeom.attributes.position.needsUpdate = true;
    // reset hearts
    hearts.forEach(h => {
      h.position.set((Math.random()-0.5)*1200, 400 + Math.random()*500, (Math.random()-0.5)*200);
      h.userData.speed = 0.8 + Math.random()*1.6;
    });
    forming = false;
    fgStarsGeom.userData.targets = null;
  }

  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // update background time (twinkle)
    if (bgUniforms) bgUniforms.time.value = t;

    // update foreground stars positions (simulate falling + forming)
    const FG_COUNT = fgPositions.length / 3;
    const targets = fgStarsGeom.userData.targets || null;
    for(let i=0;i<FG_COUNT;i++){
      const i3 = i*3;
      if (!forming || !targets || !targets[i]) {
        // falling motion with slight horizontal drift
        fgPositions[i3] += fgVel[i3]*0.2;        // x drift slight
        fgPositions[i3+1] += fgVel[i3+1]*0.9;    // y falling
        fgPositions[i3+2] += fgVel[i3+2]*0.2;
        // wrap if fallen too low
        if (fgPositions[i3+1] < -400) {
          fgPositions[i3] = (Math.random()-0.5)*1600;
          fgPositions[i3+1] = 800 + Math.random()*1200;
          fgPositions[i3+2] = (Math.random()-0.5)*600;
        }
      } else {
        // lerp to assigned target
        const tx = targets[i].x, ty = targets[i].y, tz = targets[i].z;
        fgPositions[i3] += (tx - fgPositions[i3]) * 0.06;
        fgPositions[i3+1] += (ty - fgPositions[i3+1]) * 0.06;
        fgPositions[i3+2] += (tz - fgPositions[i3+2]) * 0.06;
      }
    }
    fgStarsGeom.attributes.position.needsUpdate = true;

    // hearts: fall then gentle float / twinkle when formed
    hearts.forEach(h => {
      if (!forming) {
        h.position.y -= h.userData.speed;
        if (h.position.y < -200) {
          h.position.y = 400 + Math.random()*400;
        }
      } else {
        // when forming, hearts gently move toward center area and float
        h.position.x += Math.sin(t*0.6 + h.position.x*0.01)*0.1;
        h.position.y += Math.cos(t*0.5 + h.position.y*0.01)*0.06;
        h.rotation.y += 0.01;
      }
    });

    // slight rotation of entire scene for motion
    scene.rotation.y += 0.0004; // subtle

    // update fg shader time uniform
    if (fgStarsGeom && fgStarsGeom.userData && fgStarsGeom.userData.material) {
      fgStarsGeom.userData.material.uniforms.time.value = t;
    } else if (fgStarsGeom) {
      // find material from Points object in scene
      // (we used geom.userData.material earlier; if not set, find points)
    }

    controls.update();
    renderer.render(scene, camera);
  }

  function onResize(){
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  }

})();
</script>
</body>
</html>
