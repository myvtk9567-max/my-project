<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Em yêu anh ❤️</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
  }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>

  <style>
    html,body { margin:0; height:100%; background:#000; overflow:hidden; }
    #qr { position: fixed; right:16px; bottom:16px; background: rgba(255,255,255,0.85); padding:8px; border-radius:8px; z-index:10; }
    #music { position: fixed; left:16px; top:16px; z-index:10; }
    #hint { position: fixed; left:50%; top:8px; transform:translateX(-50%); color:#ffd1f0; font-family: sans-serif; z-index:10; }
  </style>
</head>
<body>
  <div id="hint">Kéo/zoom bằng chuột. Nếu không nghe nhạc, bấm Play.</div>

  <audio id="music" controls autoplay loop>
    <source src="https://cdn.pixabay.com/download/audio/2023/06/15/audio_61f8658c9b.mp3?filename=romantic-piano-144397.mp3" type="audio/mpeg">
  </audio>

  <div id="qr"></div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    let scene, camera, renderer, controls;
    let stars, starUniforms;
    const hearts = [];
    let targetPoints = [];
    const clock = new THREE.Clock();

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 3000);
      camera.position.set(0, 0, 400);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const p = new THREE.PointLight(0xff99dd, 1.5, 1200);
      p.position.set(200,200,200);
      scene.add(p);

      // stars
      createStars();

      // tạo chữ từ canvas (hỗ trợ tiếng Việt)
      const message = "em yêu anh, hôm nay anh đã vất vả rồi, anh là giỏi nhất";
      targetPoints = getPointsFromTextCanvas(message, {
        w: 1600,
        h: 300,
        font: "bold 140px 'Segoe UI', Arial",
        fillStyle: "#fff",
        sampleStep: 7,
        threshold: 128
      });

      // tạo geometry trái tim nhỏ
      const heartShape = new THREE.Shape();
      heartShape.moveTo(0, 5);
      heartShape.bezierCurveTo(5, 15, 25, 15, 25, 5);
      heartShape.bezierCurveTo(25, -5, 12.5, -12, 0, -25);
      heartShape.bezierCurveTo(-12.5, -12, -25, -5, -25, 5);
      heartShape.bezierCurveTo(-25, 15, -5, 15, 0, 5);
      const heartGeo = new THREE.ExtrudeGeometry(heartShape, { depth: 2, bevelEnabled: false });

      const COUNT = 700;
      for (let i = 0; i < COUNT; i++) {
        const color = new THREE.Color("hsl("+(i*360/COUNT)+",80%,60%)");
        const mat = new THREE.MeshStandardMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 1.2,
          metalness: 0.5,
          roughness: 0.3
        });
        const mesh = new THREE.Mesh(heartGeo, mat);
        mesh.scale.setScalar(0.04 + Math.random()*0.04);
        mesh.position.set((Math.random()-0.5)*1200, 500 + Math.random()*500, (Math.random()-0.5)*200);
        mesh.userData = {
          speed: 0.8 + Math.random()*1.4,
          landed: false,
          flicker: Math.random()*Math.PI*2,
          hue: Math.random()*360
        };
        scene.add(mesh);
        hearts.push(mesh);
      }

      window.addEventListener("resize", onResize);

      // QR code
      QRCode.toCanvas(document.getElementById("qr"), window.location.href, { width: 120 });
    }

    function createStars() {
      const STAR_COUNT = 15000;
      const pos = new Float32Array(STAR_COUNT * 3);
      const sizes = new Float32Array(STAR_COUNT);

      for (let i = 0; i < STAR_COUNT; i++) {
        pos[i*3]   = (Math.random()-0.5)*3000;
        pos[i*3+1] = (Math.random()-0.5)*2000;
        pos[i*3+2] = (Math.random()-0.5)*3000;
        sizes[i]   = Math.random() < 0.7 ? 1.0 + Math.random()*1.5 : 2.5 + Math.random()*2.0;
      }

      const geo = new THREE.BufferGeometry();
      geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      geo.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

      starUniforms = {
        time: { value: 0.0 }
      };

      const mat = new THREE.ShaderMaterial({
        uniforms: starUniforms,
        vertexShader: `
          attribute float size;
          varying float vSize;
          void main(){
            vSize = size;
            vec4 mv = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = vSize * (300.0 / -mv.z);
            gl_Position = projectionMatrix * mv;
          }
        `,
        fragmentShader: `
          uniform float time;
          varying float vSize;
          void main(){
            float twinkle = 0.6 + 0.4 * sin(time*3.0 + vSize*2.0);
            vec2 uv = gl_PointCoord - 0.5;
            float d = length(uv);
            float alpha = smoothstep(0.5, 0.0, d) * twinkle;
            gl_FragColor = vec4(vec3(1.0), alpha);
          }
        `,
        transparent: true,
        depthWrite: false
      });

      stars = new THREE.Points(geo, mat);
      scene.add(stars);
    }

    function getPointsFromTextCanvas(text, opts={}) {
      const w = opts.w || 1200, h = opts.h || 300;
      const font = opts.font || "bold 120px sans-serif";
      const step = opts.sampleStep || 6;
      const threshold = opts.threshold || 128;

      const c = document.createElement("canvas");
      c.width = w; c.height = h;
      const ctx = c.getContext("2d", { willReadFrequently: true });
      ctx.fillStyle = "black";
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = opts.fillStyle || "#fff";
      ctx.font = font;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, w/2, h/2);

      const img = ctx.getImageData(0,0,w,h).data;
      const pts = [];
      for (let y=0;y<h;y+=step){
        for (let x=0;x<w;x+=step){
          const idx = (y*w+x)*4;
          if (img[idx+3] > threshold){
            pts.push({x,y});
          }
        }
      }
      return pts.map(p=>{
        return new THREE.Vector3((p.x-w/2)*0.3, (h/2-p.y)*0.3-80, (Math.random()-0.5)*30);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();

      if(starUniforms) starUniforms.time.value = t;

      hearts.forEach((h,i)=>{
        if (!h.userData.landed){
          h.position.y -= h.userData.speed;
          if (h.position.y <= 30) h.userData.landed = true;
        } else if (targetPoints.length > 0){
          const target = targetPoints[i % targetPoints.length];
          h.position.lerp(target, 0.04);
          // nhấp nháy & đổi màu cầu vồng
          h.userData.hue += 0.5;
          if (h.userData.hue > 360) h.userData.hue = 0;
          const c = new THREE.Color("hsl("+h.userData.hue+",90%,60%)");
          h.material.color.copy(c);
          h.material.emissive.copy(c);
          h.material.emissiveIntensity = 1.5 + 0.5*Math.sin(t*3 + h.userData.flicker);
        }
        h.rotation.y += 0.02;
      });

      controls.update();
      renderer.render(scene, camera);
    }

    function onResize(){
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    }
  </script>
</body>
</html>
